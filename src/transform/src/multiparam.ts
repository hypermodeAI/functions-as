import {
  ArrayLiteralExpression,
  BlockStatement,
  CommonFlags,
  FloatLiteralExpression,
  FunctionDeclaration,
  IntegerLiteralExpression,
  LiteralExpression,
  LiteralKind,
  NewExpression,
  Node,
  NodeKind,
  ObjectLiteralExpression,
  ParameterKind,
  ParameterNode,
  Parser,
  Range,
  Source,
  SourceKind,
  StringLiteralExpression,
  Token,
  Tokenizer,
  ExportStatement,
  ImportStatement,
} from "assemblyscript/dist/assemblyscript.js";
import { Parameter } from "./types.js";
class OptionalParam {
  param: Parameter;
  defaultValue: string | null = null;
}

class NameMeta {
  localName: string | null;
  foreignName: string | null;
  exportedName: string | null;
  constructor(
    localName: string | null = null,
    foreignName: string | null = null,
    exportedName: string | null = null,
  ) {
    this.localName = localName;
    this.foreignName = foreignName;
    this.exportedName = exportedName;
  }
}

/**
 * Overrides the default multi-param generated by ASC
 * By default, you must have optional params declared in sequential order
 * In GraphQL that is not the case.
 *
 * This takes a function like this:
 *
 * ```js
 * fn createVec(x: i32 = 1, y: i32 = 2, z: i32 = 3) {}
 * ```
 *
 * And transforms it into
 *
 * ```js
 * fn createVec(x: i32, y: i32, z: i32, __SUPPLIED_PARAMS: u64) {
 *  if ((__SUPPLIED_PARAMS & 1) == 0) x = 1;
 *  if (((__SUPPLIED_PARAMS >> 1) & 1) == 0) y = 2;
 *  if (((__SUPPLIED_PARAMS >> 2) & 1) == 0) z = 3;
 * }
 * ```
 *
 * This works by using bitwise operations to construct a mask (__SUPPLIED_PARAMS) on the runtime-side
 *
 * `0b011` means that z was not defined, so z = 3
 *
 * `0b000` means that no params were defined, so x = 1, y = 2, z = 3
 *
 * `0b010` means that x and z were not defined, so z = 1 and z = 3
 *
 * Note that the mask is Little Endian so the order would be reversed
 */
export class MultiParamGen {
  static SN: MultiParamGen = new MultiParamGen();
  public sources: Source[] = [];
  public foreign_fns = new Map<string, NameMeta[]>();
  public foreign_files = new Set<string>();

  public exported_fns: NameMeta[] = [];
  public optional_fns = new Map<string, OptionalParam[]>();
  static init(): MultiParamGen {
    if (!MultiParamGen.SN) MultiParamGen.SN = new MultiParamGen();
    return MultiParamGen.SN;
  }
  visitFunctionDeclaration(node: FunctionDeclaration) {
    const source = node.range.source;
    const name = node.name.text;
    const exported = isExported(name, source);
    if (!exported) return;
    if (
      source.sourceKind != SourceKind.UserEntry &&
      !this.foreign_fns
        .get(source.internalPath)
        ?.find((v) => v.foreignName == name)
    )
      return;
    if (node.signature.parameters.length > 63) {
      throw new Error("Functions exceeding 64 parameters not allowed!");
    }
    const params: OptionalParam[] = [];
    for (const param of node.signature.parameters) {
      const defaultValue = getDefaultValue(param);
      params.push({
        param: {
          name: param.name.text,
          type: {
            name: "UNINITIALIZED_VALUE",
            path: "UNINITIALIZED_VALUE",
          },
          optional: !!param.initializer,
        },
        defaultValue,
      });
    }

    const exportedName = getExportedName(name, source);
    this.optional_fns.set(exportedName, params);

    if (
      node.flags == CommonFlags.Export ||
      node.flags == CommonFlags.ModuleExport
    ) {
      if (name != exportedName) {
        this.optional_fns.set(name, params);
      }
    }

    initDefaultValues(node);
  }
  visitSource(source: Source) {
    if (this.foreign_files.has(source.internalPath)) {
      for (const stmt of source.statements) {
        if (stmt.kind === NodeKind.FunctionDeclaration) {
          const node = stmt as FunctionDeclaration;
          const foreignName = node.name.text;
          const internalPath = source.internalPath;
          const exported = isExported(foreignName, source);
          const exportedName = getExportedName(foreignName, source);
          if (exported) {
            if (this.foreign_fns.has(internalPath)) {
              this.foreign_fns
                .get(foreignName)
                ?.push(new NameMeta(foreignName));
            } else {
              this.foreign_fns.set(internalPath, [new NameMeta(foreignName)]);
            }
          }
          this.exported_fns.push(
            new NameMeta(foreignName, foreignName, exportedName),
          );
          console.log(this.exported_fns);
        }
      }
    } else if (source.sourceKind === SourceKind.UserEntry) {
      for (const stmt of source.statements) {
        if (stmt.kind === NodeKind.Import) {
          const internalPath = (stmt as ImportStatement).internalPath;
          for (const node of (stmt as ImportStatement).declarations) {
            const source = node.range.source;
            if (source.sourceKind != SourceKind.UserEntry) return;
            const foreignName = getRealName(
              node.foreignName.text,
              this.sources.find((src) => src.internalPath == internalPath),
            );
            const localName = node.name.text;
            const exported = isExported(localName, source);
            if (!exported) return;
            if (this.foreign_fns.has(internalPath)) {
              this.foreign_fns
                .get(internalPath)
                .push(new NameMeta(localName, foreignName));
            } else {
              this.foreign_fns.set(internalPath, [
                new NameMeta(localName, foreignName),
              ]);
            }
          }
        } else if (stmt.kind === NodeKind.Export) {
          const node = stmt as ExportStatement;
          const internalPath = node.internalPath;
          if (internalPath) {
            if (node.members?.length) {
              if (!this.foreign_fns.has(internalPath)) {
                this.foreign_fns.set(internalPath, []);
              }
              const foreign_fns = this.foreign_fns.get(internalPath);
              for (const member of node.members) {
                const localName = member.localName.text;
                const exportedName = member.exportedName.text;
                const exists = foreign_fns.find(
                  (v) => v.localName == localName,
                );
                if (exists) {
                  exists.exportedName = exportedName;
                } else {
                  foreign_fns.push(
                    new NameMeta(localName, localName, exportedName),
                  );
                }
              }
            } else {
              this.foreign_files.add(internalPath);
            }
          } else {
            if (!node.members?.length) continue;
            for (const member of node.members) {
              const localName = member.localName.text;
              let foreignName: string = localName;
              for (const v of this.foreign_fns.values()) {
                for (const value of v) {
                  if (value.localName === localName)
                    foreignName = value.foreignName;
                }
              }
              const exportedName = member.exportedName.text;
              const meta = new NameMeta(localName, foreignName, exportedName);
              this.exported_fns.push(meta);
            }
          }
        }
      }
    }
    for (const stmt of source.statements) {
      if (stmt.kind === NodeKind.FunctionDeclaration) {
        this.visitFunctionDeclaration(stmt as FunctionDeclaration);
      }
    }
  }
}

function getDefaultValue(param: ParameterNode): string | null {
  if (!param.initializer) {
    return null;
  }

  switch (param.initializer.kind) {
    case NodeKind.Null:
      return "null";
    case NodeKind.True:
      return "true";
    case NodeKind.False:
      return "false";
    case NodeKind.New:
      if ((param.initializer as NewExpression).args.length) {
        return "{...}";
      } else {
        return "{}";
      }
    case NodeKind.Literal: {
      const literal = param.initializer as LiteralExpression;
      switch (literal.literalKind) {
        case LiteralKind.String:
          return (literal as StringLiteralExpression).value;
        case LiteralKind.Integer:
          return (literal as IntegerLiteralExpression).value.toString();
        case LiteralKind.Float:
          return (literal as FloatLiteralExpression).value.toString();
        case LiteralKind.Array:
          if ((literal as ArrayLiteralExpression).elementExpressions.length) {
            return "[...]";
          } else {
            return "[]";
          }
        case LiteralKind.Object: {
          const objLiteral = literal as ObjectLiteralExpression;
          if (objLiteral.values.length || objLiteral.names.length) {
            return "{...}";
          } else {
            return "{}";
          }
        }
      }
    }
  }

  return "...";
}

const parser = new Parser();
function newIntegerLiteral(
  num: number,
  range: Range,
): IntegerLiteralExpression {
  const source = new Source(
    SourceKind.User,
    range.source.normalizedPath,
    num.toString(),
  );
  const tokenizer = new Tokenizer(source);
  parser.currentSource = source;
  const int = parser.parseExpression(tokenizer) as IntegerLiteralExpression;
  int.range = range;
  return int;
}

function initDefaultValues(node: FunctionDeclaration) {
  if (
    node.signature.parameters.find(
      (v) => v.parameterKind === ParameterKind.Optional,
    )
  ) {
    let body: BlockStatement;
    if (node.body.kind != NodeKind.Block) {
      body = Node.createBlockStatement([node.body], node.range);
    } else {
      body = node.body as BlockStatement;
    }
    node.signature.parameters.push(
      Node.createParameter(
        ParameterKind.Default,
        Node.createIdentifierExpression("__SUPPLIED_PARAMS", node.range, false),
        Node.createNamedType(
          Node.createSimpleTypeName("u64", node.range),
          [],
          false,
          node.range,
        ),
        null,
        node.range,
      ),
    );
    let first = true;
    for (let i = 0; i < node.signature.parameters.length; i++) {
      const param = node.signature.parameters[i];
      if (param.parameterKind != ParameterKind.Optional) continue;
      const stmt = Node.createIfStatement(
        Node.createBinaryExpression(
          Token.Equals_Equals,
          Node.createParenthesizedExpression(
            Node.createBinaryExpression(
              Token.Ampersand,
              first
                ? ((first = false),
                  Node.createIdentifierExpression(
                    "__SUPPLIED_PARAMS",
                    node.range,
                  ))
                : Node.createParenthesizedExpression(
                    Node.createBinaryExpression(
                      Token.GreaterThan_GreaterThan,
                      Node.createIdentifierExpression(
                        "__SUPPLIED_PARAMS",
                        node.range,
                      ),
                      newIntegerLiteral(i, node.range),
                      node.range,
                    ),
                    node.range,
                  ),
              newIntegerLiteral(1, node.range),
              node.range,
            ),
            node.range,
          ),
          newIntegerLiteral(0, node.range),
          node.range,
        ),
        Node.createExpressionStatement(
          Node.createBinaryExpression(
            Token.Equals,
            Node.createIdentifierExpression(param.name.text, node.range, false),
            param.initializer,
            node.range,
          ),
        ),
        null,
        node.range,
      );
      body.statements.unshift(stmt);
      if (param.initializer) param.initializer = null;
    }
  }
}

function isExported(name: string, source: Source): boolean {
  let i = source.statements.length - 1;
  while (i >= 0) {
    const stmt = source.statements[i];
    if (stmt.kind === NodeKind.FunctionDeclaration) {
      const node = stmt as FunctionDeclaration;
      return (
        node.flags === CommonFlags.Export ||
        node.flags === CommonFlags.ModuleExport
      );
    } else if (stmt.kind === NodeKind.Export) {
      const node = stmt as ExportStatement;
      // export { ... } from "..."
      if (node.members) {
        for (const member of node.members) {
          const localName = member.localName.text;
          if (name === localName) return true;
        }
      }
    }
    i--;
  }
  return false;
}

function getExportedName(name: string, source: Source): string {
  const exists = MultiParamGen.SN.exported_fns.find(
    (v) => v.foreignName == name,
  );
  if (exists) return exists.exportedName;
  let i = source.statements.length - 1;
  while (i >= 0) {
    const stmt = source.statements[i];
    if (stmt.kind === NodeKind.Export) {
      const node = stmt as ExportStatement;
      // export { ... } from "..."
      if (node.members) {
        for (const member of node.members) {
          const localName = member.localName.text;
          const exportedName = member.exportedName.text;
          if (name === localName) return exportedName || localName;
        }
      }
    }
    i--;
  }
  return name;
}

function getRealName(name: string, source: Source): string {
  if (!source || !source?.statements) return name;
  for (const stmt of source.statements) {
    if (stmt.kind === NodeKind.Export) {
      const node = stmt as ExportStatement;
      if (node.members) {
        for (const member of node.members) {
          const localName = member.localName.text;
          const exportedName = member.exportedName.text;
          if (name === exportedName) return localName;
        }
      }
    }
  }
  return name;
}
